<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SU(N) Tensor Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-space: #0f172a;
            --bg-panel: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
            --accent-pink: #ec4899;
            --border-subtle: #334155;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-space);
            color: var(--text-primary);
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(139, 92, 246, 0.08), transparent 25%), 
                radial-gradient(circle at 85% 30%, rgba(236, 72, 153, 0.08), transparent 25%);
        }
        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Scientific Panel Style */
        .sci-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.75rem;
        }
        .sci-input {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        .sci-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }
        .sci-btn {
            background: linear-gradient(135deg, var(--accent-purple), #7c3aed);
            color: white;
            border: none;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.2);
        }
        .sci-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(124, 58, 237, 0.3);
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-slate-200">

    <!-- Navbar -->
    <nav class="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 p-4 flex justify-between items-center shrink-0 z-10">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-gradient-to-br from-purple-500 to-pink-600 rounded-lg flex items-center justify-center font-bold text-white shadow-lg shadow-purple-500/20">⊗</div>
            <div>
                <h1 class="text-lg font-semibold tracking-tight text-white">Tensor Product Lab</h1>
                <div class="text-[10px] text-slate-400 font-mono tracking-wide">REPRESENTATION DECOMPOSITION</div>
            </div>
        </div>
        <div class="flex items-center gap-4">
            <a href="index.html" class="text-slate-400 hover:text-white text-xs font-bold uppercase tracking-wider transition-colors flex items-center gap-2 px-3 py-1.5 rounded-lg hover:bg-slate-800 border border-transparent hover:border-slate-700">
                <span class="text-lg leading-none">&larr;</span> Return to Main
            </a>
        </div>
    </nav>

    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Left Sidebar: Controls -->
        <aside class="w-full md:w-80 bg-slate-900/50 border-r border-slate-800 flex flex-col z-20 overflow-y-auto backdrop-blur-sm">
            
            <div class="p-6 space-y-8">
                
                <!-- Group Selection -->
                <div class="space-y-3">
                    <label class="text-xs font-bold uppercase tracking-wider text-slate-500 flex items-center gap-2">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                        Symmetry Group
                    </label>
                    <div class="flex items-center justify-center sci-panel py-3 px-4 group hover:border-purple-500/30 transition-colors">
                        <span class="text-slate-400 font-serif italic text-xl select-none mr-1">SU(</span>
                        <input type="number" id="groupN" value="3" min="2" max="20" 
                            class="w-12 bg-transparent font-mono text-purple-400 font-bold focus:outline-none text-center text-2xl"
                            onchange="initApp()">
                        <span class="text-slate-400 font-serif italic text-xl select-none ml-1">)</span>
                    </div>
                </div>

                <!-- Partition Input -->
                <div class="space-y-3">
                    <label class="text-xs font-bold uppercase tracking-wider text-slate-500 flex items-center gap-2">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                        Tableau 1 (λ)
                    </label>
                    <div class="flex flex-col gap-3">
                        <input type="text" id="partitionInput" value="2, 1" 
                            class="w-full sci-input rounded-lg px-3 py-2.5 font-mono text-sm text-purple-300 placeholder-slate-600"
                            placeholder="e.g. 2, 1">
                        <button onclick="initApp()" class="sci-btn rounded-lg px-4 py-2 font-semibold text-xs uppercase tracking-wide">
                            Set Tableau 1
                        </button>
                    </div>
                </div>

                <!-- Tensor Product Input -->
                <div class="space-y-3 pt-4 border-t border-slate-800">
                    <label class="text-xs font-bold uppercase tracking-wider text-slate-500 flex items-center gap-2">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                        Tableau 2 (μ)
                    </label>
                    <div class="flex flex-col gap-3">
                        <input type="text" id="tensorInput" placeholder="e.g. 1" value="1"
                            class="w-full sci-input rounded-lg px-3 py-2.5 font-mono text-sm text-pink-300 placeholder-slate-600 focus:border-pink-500 focus:shadow-[0_0_0_2px_rgba(236,72,153,0.2)]">
                        <button onclick="startTensorViz()" class="sci-btn rounded-lg px-4 py-2 font-semibold text-xs uppercase tracking-wide bg-gradient-to-br from-pink-500 to-rose-600 shadow-pink-500/20 hover:shadow-pink-500/30">
                            Run Decomposition
                        </button>
                    </div>
                </div>

            </div>
        </aside>

        <!-- Main Canvas -->
        <main class="flex-1 bg-[#0f172a] relative flex flex-col p-4 md:p-8 overflow-y-auto">
            
            <!-- Background Grid -->
            <div class="absolute inset-0 opacity-[0.03]" style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 24px 24px;"></div>

            <!-- Tensor Product Visualization -->
            <div id="tensorSection" class="w-full max-w-6xl mx-auto z-10 pb-20">
                <div class="flex justify-between items-end mb-8 border-b border-slate-800 pb-4">
                    <h2 class="text-purple-400 text-xs font-bold uppercase tracking-widest flex items-center gap-3">
                        <span class="w-2 h-2 rounded-full bg-purple-500 animate-pulse"></span> Visualization Sequence
                    </h2>
                    
                    <!-- Step Controls -->
                    <div class="flex items-center gap-1 bg-slate-800/50 rounded-lg p-1 border border-slate-700/50 backdrop-blur-sm">
                        <button onclick="prevStep()" class="px-4 py-1.5 text-slate-400 hover:text-white hover:bg-slate-700/50 rounded-md transition-colors text-xs font-medium uppercase tracking-wide">Prev</button>
                        <span id="stepIndicator" class="text-xs font-mono text-purple-300 px-4 min-w-[100px] text-center font-bold">Step 0</span>
                        <button onclick="nextStep()" class="px-4 py-1.5 text-slate-400 hover:text-white hover:bg-slate-700/50 rounded-md transition-colors text-xs font-medium uppercase tracking-wide">Next</button>
                    </div>
                </div>

                <!-- Step Description -->
                <div id="stepDescription" class="text-center mb-8 text-slate-300 font-medium bg-slate-800/30 py-4 rounded-xl border border-slate-700/30 backdrop-blur-sm">
                    Awaiting Input...
                </div>

                <!-- Visualization Container -->
                <div id="vizContainer" class="flex flex-wrap justify-center gap-12 min-h-[200px]">
                    <!-- Shapes injected here -->
                </div>
            </div>

        </main>
    </div>

    <script>
        // --- State ---
        var partition = [];
        var suN = 3;
        
        // Tensor Viz State
        var tensorSteps = [];
        var currentStepIndex = 0;
        var tensorP2 = [];

        // --- Core Logic ---

        function initApp() {
            // 1. Parse SU(N)
            suN = parseInt(document.getElementById('groupN').value) || 3;

            // 2. Parse Partition
            const input = document.getElementById('partitionInput').value;
            const parts = input.split(/[,\s]+/)
                               .map(n => parseInt(n))
                               .filter(n => !isNaN(n) && n > 0);
            partition = parts.sort((a, b) => b - a); // Standard shape

            // If we have a tensor input already, maybe re-run viz? 
            // For now, just update state. User clicks Viz to run.
        }

        function getHookLength(r, c, shape = partition) {
            const right = shape[r] - 1 - c;
            let below = 0;
            for (let i = r + 1; i < shape.length; i++) {
                if (shape[i] > c) below++;
            }
            return right + below + 1;
        }

        function getNumeratorValue(r, c) {
            return suN + (c - r);
        }

        // --- Rendering ---

        function renderGrid(type, container, customShape = null, highlightData = null) {
            container.innerHTML = '';
            const shapeToRender = customShape || partition;

            shapeToRender.forEach((cols, r) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'flex gap-1';
                
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    
                    // Default Style
                    let baseClass = "w-10 h-10 md:w-12 md:h-12 border border-[#333] flex items-center justify-center text-sm md:text-base font-mono font-bold select-none transition-all ";
                    let content = "";

                    // Determine Content & specific styles
                    if (type === 'viz') {
                        // Visualization Mode
                        content = ""; // Empty usually, or label
                        
                        // Check if this cell is "Added" in this step
                        // highlightData contains info about cell types: 'base', 'added-1', 'added-2'
                        const cellType = highlightData ? highlightData[r]?.[c] : 'base';

                        if (cellType === 'base' || !cellType) {
                            baseClass += "bg-[#111] border-[#333] text-[#555]";
                        } else if (cellType === 'added-1') { // Row 1 added
                            baseClass += "bg-[#d946ef]/20 border-[#d946ef] text-[#d946ef] animate-pulse shadow-[0_0_10px_rgba(217,70,239,0.3)]";
                            content = "a";
                        } else if (cellType === 'added-2') { // Row 2 added
                            baseClass += "bg-[#ec4899]/20 border-[#ec4899] text-[#ec4899] animate-pulse shadow-[0_0_10px_rgba(236,72,153,0.3)]";
                            content = "b";
                        } else if (cellType === 'added-3') {
                             baseClass += "bg-[#f97316]/20 border-[#f97316] text-[#f97316] shadow-[0_0_10px_rgba(249,115,22,0.3)]";
                             content = "c";
                        }
                    }

                    cell.className = baseClass;
                    cell.innerText = content;
                    rowDiv.appendChild(cell);
                }
                container.appendChild(rowDiv);
            });
        }


        // --- Tensor Visualization Logic ---

        function startTensorViz() {
            initApp(); // Ensure state is fresh
            const tInput = document.getElementById('tensorInput').value;
            tensorP2 = tInput.split(/[,\s]+/).map(n => parseInt(n)).filter(n => !isNaN(n));
            
            if (tensorP2.length === 0) return;

            // Generate Steps
            tensorSteps = generateTensorSteps(partition, tensorP2, suN);
            currentStepIndex = 0;
            
            renderTensorStep();
        }

        function nextStep() {
            if (currentStepIndex < tensorSteps.length - 1) {
                currentStepIndex++;
                renderTensorStep();
            }
        }

        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                renderTensorStep();
            }
        }

        function renderTensorStep() {
            const stepData = tensorSteps[currentStepIndex];
            const container = document.getElementById('vizContainer');
            container.innerHTML = '';

            document.getElementById('stepIndicator').innerText = `Step ${currentStepIndex} / ${tensorSteps.length - 1}`;
            document.getElementById('stepDescription').innerHTML = stepData.description;

            if (stepData.shapes.length === 0) {
                container.innerHTML = '<div class="text-slate-500 italic">No valid configurations found.</div>';
                return;
            }

            stepData.shapes.forEach(item => {
                const wrapper = document.createElement('div');
                wrapper.className = "flex flex-col items-center gap-2 fade-in";
                
                // Label (if exists)
                if (item.label) {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = "text-xs font-bold text-slate-500 uppercase tracking-wider mb-1";
                    labelDiv.innerText = item.label;
                    wrapper.appendChild(labelDiv);
                }
                
                // Render grid small
                const gridDiv = document.createElement('div');
                gridDiv.className = "flex flex-col items-start gap-px transform scale-90"; // slightly smaller
                
                // Custom render for viz
                renderGrid('viz', gridDiv, item.shape, item.map);
                
                wrapper.appendChild(gridDiv);

                // Show dimension for all steps
                const dimDiv = document.createElement('div');
                const dim = calculateDimForShape(item.shape);
                dimDiv.className = "text-xs font-bold text-purple-300 bg-purple-900/30 px-2 py-1 rounded border border-purple-500/20";
                dimDiv.innerText = "dim: " + dim.toLocaleString();
                wrapper.appendChild(dimDiv);

                container.appendChild(wrapper);
            });
        }

        function calculateDimForShape(shape) {
             let num = 1n, den = 1n;
             for(let r=0; r<shape.length; r++) {
                 for(let c=0; c<shape[r]; c++) {
                     let hook = getHookLength(r, c, shape);
                     let val = suN + (c - r);
                     num *= BigInt(val);
                     den *= BigInt(hook);
                 }
             }
             return den === 0n ? 0n : num/den;
        }

        // --- Littlewood-Richardson Step Generator ---

        function generateTensorSteps(p1, p2, nCap) {
            // Step 0: Base
            let steps = [{
                description: "Start with the initial tableaux.",
                shapes: [
                    { shape: [...p1], map: createBaseMap(p1), label: "Tableau 1" },
                    { shape: [...p2], map: createBaseMap(p2), label: "Tableau 2" }
                ]
            }];

            let currentGeneration = [{ shape: [...p1], map: createBaseMap(p1) }]; // Only expand from p1

            // Iterate through rows of P2
            p2.forEach((count, rowIndex) => {
                const label = ['added-1', 'added-2', 'added-3'][rowIndex] || 'added-x';
                const labelChar = ['a', 'b', 'c'][rowIndex] || '?';
                
                let nextGeneration = [];
                
                // Expand each current shape
                currentGeneration.forEach(parent => {
                    const expansions = expandShape(parent.shape, parent.map, count, label, nCap);
                    nextGeneration.push(...expansions);
                });

                // Deduplicate shapes for display (optional, but good for clean viz)
                // Actually, distinct maps matter here.
                
                steps.push({
                    description: `Add <strong>${count}</strong> boxes (${labelChar}) from row ${rowIndex + 1} of the second tableau.<br><span class="text-xs opacity-70">Rule: No two new boxes in the same column.</span>`,
                    shapes: nextGeneration
                });

                currentGeneration = nextGeneration;
            });

            // Final Step: Add final tally
            steps.push({
                description: "<strong>Final Decomposition</strong><br><span class=\"text-xs opacity-70\">Check Lattice Permutation Rule & SU(N) Validity</span>",
                shapes: currentGeneration // In a full implementation, we filter by Lattice Permutation here. simplified logic usually ensures it by add order.
            });

            return steps;
        }

        function createBaseMap(shape) {
            let map = [];
            shape.forEach(c => {
                map.push(new Array(c).fill('base'));
            });
            return map;
        }

        function expandShape(shape, map, count, labelType, nCap) {
            // Adds 'count' boxes of 'labelType' to 'shape' according to Pieri's rule (single row add)
            // Returns array of { shape: [...], map: [...] }
            
            let results = [];
            
            // Recursive adder
            function addBoxes(currentS, currentM, k, startRow) {
                if (k === 0) {
                    // Valid shape formed
                    if (currentS.length <= nCap) { // SU(N) constraint on rows? No, on columns (length <= N)
                         // Check Max Column Length?
                         // Actually, shape length = number of rows. 
                         // In SU(N), we shouldn't have more than N rows usually? 
                         // Yes, columns of length N+1 are zero.
                         if (currentS.length <= nCap) {
                             results.push({ shape: JSON.parse(JSON.stringify(currentS)), map: JSON.parse(JSON.stringify(currentM)) });
                         }
                    }
                    return;
                }

                // Try adding to row r
                for (let r = startRow; r <= currentS.length; r++) {
                    // Constraints:
                    // 1. Convexity: newS[r] < newS[r-1] (before adding, check capacity)
                    // Actually, after adding, newS[r] must be <= newS[r-1]
                    
                    // Logic: We are adding to row r.
                    // If r=0, always ok.
                    // If r>0, need currentS[r] < currentS[r-1]. 
                    // Wait, Pieri's rule says "no two boxes in same column".
                    // This implies we add to distinct columns.
                    // The recursive param `startRow` handles the "distinct columns" logic (always move down).
                    
                    // Check if adding to row r maintains partition property with PREVIOUS rows
                    let canAdd = true;
                    if (r > 0) {
                        if (currentS[r] === undefined) { // New row
                             // Can only create new row if prev row is strictly larger? No, just >=
                             // But we are adding 1.
                             // New row len becomes 1. Prev row must be >= 1.
                             if (currentS[r-1] < 1) canAdd = false;
                        } else {
                             // Existing row
                             // If we add 1, it becomes currentS[r]+1.
                             // Must be <= currentS[r-1].
                             if (currentS[r] + 1 > currentS[r-1]) canAdd = false;
                        }
                    }
                    
                    if (!canAdd) continue;

                    // Prepare new state
                    let nextS = [...currentS];
                    let nextM = currentM.map(row => [...row]);

                    if (nextS[r] === undefined) {
                        nextS[r] = 1;
                        nextM[r] = [labelType];
                    } else {
                        nextS[r]++;
                        nextM[r].push(labelType);
                    }
                    
                    // Recurse, startRow = r + 1 (Strictly down to ensure distinct columns for THIS batch of boxes)
                    addBoxes(nextS, nextM, k-1, r + 1);
                }
            }

            addBoxes(shape, map, count, 0);
            return results;
        }

        // Initial Load
        window.onload = initApp;

    </script>
</body>
</html>
